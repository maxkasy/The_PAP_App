Column {data-width=300}
-------------------------------------
    
    
### Parameters
    
Separate probabilities by comma!
```{r}
textInput("etaJ_binary", "Probability of observing components", value = "0.9,0.5", width = NULL,
          placeholder = NULL)
```


Prior parameters of beta prior:
    ```{r}
numericInput('alpha', 'alpha', 1, step = .1, min = 0)
numericInput('beta', 'beta', 1, step = .1, min = 0)
```

Test:
    ```{r}
numericInput('minp_binary', 'Null hypothesis', .2, step = .1, min = 0, max = 1)
numericInput('size_binary', 'Size of test', .1, step = .01, min = 0, max = 1)
checkboxInput("simple_pap_binary", "Use a simple cutoff rule", FALSE)
```



```{r}
actionButton('run_binary', 'Run')
```






Column {data-width=400}
-------------------------------------
    
    
    ```{r}
#object to store calculation results
v_binary = reactiveValues()

observeEvent(input$run_binary, {
    v_binary$etaJ = unlist(strsplit(input$etaJ_binary, ",")) |> as.numeric()
    
    # Check if input values are valid numerical vector
    v_binary$valid_inputs = check_inputs_binary_data(etaJ = v_binary$etaJ,
                           minp = input$minp_binary, size = input$size_binary,
                           alpha = input$alpha, beta = input$beta)
    
    if (v_binary$valid_inputs){ 
        if (input$simple_pap_binary == F){ # Use the optimal test
            v_binary$output = pap_binary_data(etaJ = v_binary$etaJ,
                               minp = input$minp_binary, size = input$size_binary,
                               alpha = input$alpha, beta = input$beta) 
           v_binary$output$test = v_binary$output$test |>
                filter(t>0) |>
                arrange(t)
        } else { # Use a simple test
            v_binary$output = pap_binary_data_simple(etaJ = v_binary$etaJ,
                               minp = input$minp_binary, size = input$size_binary,
                               alpha = input$alpha, beta = input$beta)
        }
    } else {
        v_binary$output$test = "Invalid input values"
        v_binary$output$expected_power = NaN
    }
})
```



### The optimal PAP {data-height=700}
```{r}
renderTable({
    req(v_binary$output)
    v_binary$output$test
},
digits = 2
)
```

### Notes {data-height=200}

For optimal PAPs, each row of this table shows a possible combination of values for X, and the corresponding rejection probability t of the optimal full data test.
Values of X that are not displayed have t = 0 (no rejection).

For simple cutoff rules, the table shows the components of X used by the test, the cutoff in terms of the sum of these components, and the rejection probability when the sum is exactly at the cutoff.

### Save optimal PAP as *csv* file. {data-height=100}

```{r}
downloadLink("download_binary", "Download PAP", style = "font-size: 20px;")
output$download_binary = 
    downloadHandler(
    filename = paste(Sys.Date(), "_binary_pap.csv", sep = ""),
    content = function(file) {
        write_csv(v_binary$output, file)
    }
)
```

Column {data-width=300}
-------------------------------------

### Expected power

```{r}
renderValueBox({
  valueBox(round(mean(v_binary$output$expected_power), digits=2))
})
```



